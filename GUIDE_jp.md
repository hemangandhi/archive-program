# GitHub Code Vaultのガイド

## 前書き

このアーカイブであるGitHub Code Vaultは、GitHub Archive Programによって設立されました。その使命は、次世代のオープンソースソフトウェアを保護することです。あなたはこれを1年後または1000年後に読んでいるかもしれませんが、どちらにしても、その内容、そしておそらくオープンソースの概念があなたにとって役立つことを願っています。

これは主にソフトウェアのアーカイブです。ソフトウェアは、コンピュータの動作を制御するために使用されるコマンドです。コンピュータは、人間の頭脳よりもはるかに速く数学関数を自動的に実行できるデバイスであり、私たちをはるかに超えた能力を持っています。私たちのコンピューターは、宇宙の神秘を探究し、遍在する情報のウェブで人類のすべてを結び付け、高速信号処理使って音を送信や動画を電気スクリーンで投影など出来て、非常に強力な機械を制御するために使用されます人間の労働力と能力の両方を超えています。

ソフトウェアのないコンピュータは、これらのことは何もできません。コンピュータは並外れて素晴らしいものですが、ソフトウェアがなければ、その能力はすべて役に立ちません。このアーカイブの目的は、ソフトウェアについて私たちが知っていることをあなたに伝えることです。

ソフトウェアの完全な単位はプログラムと呼ばれることが多いため、ソフトウェアは複雑であるが人間が読めるコマンドのシーケンスとして記述され、そのさまざまなフレーバーはプログラミング言語と呼ばれます。これらのプログラムは、コンピュータで使用される1と0のバイナリ言語に変換されます。このプロセスはコンパイルと呼ばれます。

コンパイルされたソフトウェアは、元のプログラム形式（ソースコードとも呼ばれる）に解読するのが非常に難しいため、元の形式を秘密にして所有権を主張することは可能です。オープンソースソフトウェアは別の種類のソフトウェアではなく、別の精神です。オープンソースの精神は、秘密と所有権を拒否します。オープンソースソフトウェアプログラムは、すべての人が無料で利用できたり、プログラムを改善したり、新しい優れたものを構築するために使用したりできます。

オープンソースプロジェクトは、数千に及ぶ可能性のある自己組織化コミュニティの共同作業です。ここにアーカイブされたすべてのオープンソースソフトウェアプロジェクトの蓄積は、数百万のコミュニティの成果です。特定の個人は、特定のプロジェクト内で、ソースコードの最新の公式バージョンに対する提案された変更を承認または拒否する機能などの特別な権利を持っている場合がありますが、誰もそれを所有していません。すべての人は、オープンソースプロジェクトの完全なコピーをいつでも、費用やペナルティなしに取得して使用するあらゆる権利を持っています。これは、プロジェクトのフォークと呼ばれます。

多くの人が同時にソースコードに取り組んでいる場合、すべての変更を追跡して統合することは困難です。とあるオープンソースプロジェクト「Git」は、この問題の解決に専念しています。プロジェクトへのすべての追加と変更の完全な履歴を、Gitリポジトリと呼ばれるエンティティに統合します。このアーカイブは、基本的にそのようなリポジトリのアーカイブです。

このアーカイブは「GitHub」という名前の会社が作成したもので、世界中の人々が作成したソフトウェアプログラムを保存し、これらのプログラムに対する変更を追跡し、他のユーザーと協力してそれらを改善および拡張できるサービスを提供しています。GitHubは、パブリックオープンソースソフトウェアの開発者が無料でサービスを利用できるようにします。そのようなユーザーは数千万人います。

以下は、このソフトウェアアーカイブを最大限に活用するために知っておく必要があると私たちが信じるものの説明です。これの一部またはすべてを理解または理解していない場合は、絶望しないでください！これらの要件を達成する方法のガイドも含まれています。何らかの理由で自分で達成できない場合、子孫は達成できます。

## アーカイブを使用するために必要なもの

原則として、このアーカイブのコンテンツにアクセスするために必要なのは、照明の源であり、なんらかの拡大鏡です。ただし、そのデータのほとんど（すべてではありません）は、エンコードされ圧縮された形式でフィルムリールに非常に密にパックされています。このデータの読み取り、デコード、および解凍には、かなりの計算自体が必要になります。理論的には、コンピューターなしで行うこともできますが、非常に面倒で困難です。

私たちの期待は、ソフトウェア、コンピューター、その他の用語の定義を必要としないことです。私たちはあなたが自分のコンピュータを持っていると想像します。おそらく私たちのものよりもはるかに高度で、おそらく根本的に異なって設計されています。以下の概要とガイドを理解すると、すべてのデータに簡単にアクセスできるようになります。

ただし、コンピューターが劣っている場合や、コンピューターがまったくない場合もあります。そのような事態が発生した場合に備えて、非圧縮でエンコードされていない人間が読み取れるデータのリールを用意しました。これをテックツリーと呼びます。技術ツリーには、基本的なテクノロジー、コンピューター、およびソフトウェアに関する情報が含まれています。今後、この知識を使用して、このアーカイブのオープンソースソフトウェアを利用できるコンピューターを再作成できるようになることを期待しています。

## 中身

アーカイブは非常に大きく、約24兆バイト（以下で説明）です。これは、非常に包括的で民主的なためです。何百万もの人々が、自分が書いたソフトウェアを誰もが利用できるようにします。このアーカイブには、GitHubのユーザーが積極的に開発しているすべての公開ソフトウェアのスナップショット（つまり、ある時点での単一のコピー）が含まれています。つまり、数千万の個別のリポジトリが含まれています。私たちの希望は、この広く民主的なアプローチが、将来の歴史家にとって興味深いものになることです。

このアーカイブに含まれるリポジトリは、最後のコミット時刻、つまり最後に更新された時刻、およびスター数によって純粋に決定されました。 （GitHubのユーザーはすべて、パブリックリポジトリに「スター」を付けて、関心があるか重要であることを示すことができます。）スナップショットは、2020年2月2日、つまり2月の2日目の、時間を数えるグレゴリオ暦の2020年。含まれているリポジトリは次のとおりです。過去80日以内にコミットされたすべてのリポジトリ。過去365日以内にコミットされた星が1つ以上あるすべてのリポジトリ。そして、それらが最後に更新された時期に関係なく、少なくとも250個の星を持つすべてのリポジトリ。

もちろん、これらのリポジトリのすべてが、その影響力と依存関係の点で等しく重要であるとは限りません。技術ツリーには、アーカイブ内の最も重要なリポジトリのインデックスと簡単な説明、および各リールを見つけることができるリストが含まれているため、何百万ものリポジトリを調べて最も実用的なリポジトリを特定する必要なくアクセスできます。有用。

## アーカイブの概要

アーカイブは、フィルムの201リールで構成されています。人間が読める情報とガイダンスの1つの「ガイドリール」と、アーカイブされたソフトウェアの200リールです。各リールには、65,000の個別のフレームが含まれています。各リールの先頭のフレームとガイドリールのフレームには、人間が読み取れるテキストと画像が含まれています。他のすべてのフィルムフレームは、QRコードと呼ばれる視覚的な形式で保存されたデジタルデータで構成されています。

デジタルデータとは、コンピューター自体がバイナリであるため、最終的にバイナリ形式で、つまり0と1として保存されるデータを意味します。1または0に対応する「オン」または「オフ」の電気信号によって制御されるため、バイナリデータはコンピュータが他のどれよりも非常に理解しやすい。

各リールの最初に保存されている人間が読み取れるメタデータには、フィルム自体に関する情報、使用されるQRエンコーディングのガイド、それをデコードするソフトウェアプログラム、およびインデックスが含まれています。インデックスには、そのリールに保存されている各ファイルのタイトル、開始フレーム番号、チェックサムが一覧表示されます。

ファイルは単一の一貫したデータエンティティです。チェックサムは、ハッシュ関数と呼ばれる計算からの一意の値で、ファイルのコンテンツ全体に対して実行され、そのコンテンツが破損または破損していないことを確認します。アーカイブで使用されるハッシュ関数は「SHA-1」として知られています。

各QRコードは、フィルムのフレーム全体を占める小さな白または黒の正方形のフィールドで構成されています。人間が読み取れるテキストよりもはるかにコンパクトで堅牢なQRコードを使用しています。QRコードはバイナリデータ、つまり一連の1と0にデコードされます。

このデコードは、そのバイナリデータを意味のある情報に変換する最初のステップにすぎません。これは圧縮されたデータです。つまり、スペースを節約するために圧縮されており、文字Aを128回書き込むのではなく、「128xA」を書き込む方法と似ています。デコード後、解凍する必要があります。

解凍後の結果はアーカイブファイルと呼ばれます。これは、単一のソフトウェアプロジェクトのリポジトリの内容全体を含む単一のファイルです。ほとんどのリポジトリには多くのファイルが含まれているため、このアーカイブファイルは、多くの個別の章を含む本や、他の多くのボックスを含むボックスのようなものです。絶対に必要というわけではありませんが、一般に、アクセスする前にアーカイブファイルをコンポーネントファイルに解凍することは有利です。

最後に、各コンポーネントファイルは、1と0のバイナリデータの独自のセットです。データの形式がわかっていれば、データを理解することができます。たとえば、アーカイブで最も一般的な形式である「UTF-8」として知られる形式では、1と0はバイトと呼ばれる8つのグループに分割され、バイト01000001は文字Aを表します。 3バイトの01101001 01101110 01110100は、intという単語を表します。 2バイト11000011 10000011は文字representを表します（上部にティルダアクセントが付いたA）。

このデータアーカイブプロセスは、最初に圧縮されてからQRエンコードされたアーカイブファイルにパックされたバイナリファイルであり、人間が読み取れるテキストを書き込むだけの場合と比べて明らかに複雑です。実行する必要があるアーカイブ解除プロセス-QRから圧縮バイナリ;圧縮されて非圧縮;ファイルを複数のファイルにアーカイブします。テキストファイルを人間が読める形式のテキストに変換する-同様に複雑です。これは、この複雑さにより、他の方法では可能な場合よりもはるかに多くのデータを、比較的簡単にコンピューターで読み取り可能な方法で格納できるためです。

この複雑さが困難で費用がかかる場合はお詫びしますが、このガイドと人間が読める技術ツリーを使用すると、この複雑さが緩和され、おそらくよりも役立つと思われます。少なくともアーカイブのデータの複雑さを処理するのが簡単になるほどコンピュータが高度になるまで、コンテンツをアーカイブします。

## ファイル、ディレクトリ、リポジトリ、およびデータ形式

アーカイブが論理的にどのように分割されているかを議論することは有益かもしれません。特に、ファイル、ディレクトリ、およびデータ形式の説明が役立つ可能性があります。

ファイルとは、データを砂のようなものとしてグループ化されたデータの集まりです。データは砂であり、ファイルは砂を保持できる一種の袋であり、砂のみです。ディレクトリはファイルのコレクションです。他のバッグのみを保持できる一種のバッグと考えてください。このメタファーに続いて、すべてのリポジトリは、ルートディレクトリと呼ばれる外部ディレクトリで構成されます。このディレクトリには、多数のファイルやディレクトリが含まれています。各ディレクトリには、ファイルとディレクトリの両方を含めることができます。

グループに編成されたファイルは、単一のファイルのコレクションよりもはるかに扱いやすいため、この構造が推奨されます。外部ディレクトリ内の特定のファイルの識別子は、ルートで始まり、その後に独自の名前が続き、すべての名前の間に/文字が付いた、そのファイルを囲むすべてのディレクトリの名前で構成されます。たとえば、ルートディレクトリ内のREADME.mdという名前のファイルは/README.mdとして識別され、/ public / www / index.htmlとして識別されるファイルは、 '内の' www 'ディレクトリ内のファイルindex.htmlになります。ルートディレクトリ内のパブリックディレクトリ。

各リポジトリには2つの名前があり、区切り文字で区切られています。アーカイブでは、_またはアンダースコア文字です。 （これまでは/またはスラッシュでしたが、これはディレクトリを示すためにも使用されるため、わかりやすくするために_を使用しています。）最初の名前は、そのリポジトリを所有するGitHubアカウントです。 2つ目は、個々のリポジトリの名前です。リポジトリとファイル識別子の組み合わせを使用して、アーカイブ内の個々のファイルを一意に識別できます。たとえば、GitHubアカウント「rezendi」内のリポジトリ「ykarma」のディレクトリ「web」にあるファイル「package.json」は、アーカイブ内のrezendi_ykarma内の/web/package.jsonとして一意に識別できます。

ファイルの種類が異なれば目的も異なります。GitHubアーカイブは、主にテキストファイルで構成されています。つまり、書かれた言語を表すためのデータを持つファイルです。ほとんどのソフトウェアは、ソースコードと呼ばれる高度に構造化されたテキストを含むテキストファイルで記述されています。コンパイラと呼ばれる特別なプログラムは、人間が読み取れるソースコードを、コンパイルされたコードまたはマシンコードと呼ばれるコンピュータが読み取り可能な命令に変換します。

ビジュアルイメージを表すファイルやコンパイルされたコードを含むファイルなど、テキストファイルではないファイルは、多くの場合、バイナリファイルと呼ばれます。テキストファイルも最終的に1と0になるため、これは残念ながら誤解を招く用語です。テキストファイルではないファイルを非テキストファイルと呼びます。

1と0を使用して人間の書き言葉を表現する方法はたくさんあります。歴史的な理由により、ほとんどのソースコードは元々はラテン文字と呼ばれるもので書かれていました。ラテン文字には26の基本文字があり、読みやすい単語を表すために使用されます。それぞれの文字には、大文字と小文字の2つの形式があります。また、数字を表す10桁の数字もあります。ラテン語のスクリプトは、構造やその他の概念を示すために使用される他のさまざまな関連記号とともに、「ASCII」と呼ばれる形式で1と0にエンコードされます。 。

ただし、ラテン文字は、人間が書き言葉で自分を表現する多くの方法のごく一部にすぎません。他のスクリプトをサポートするために、ASCIIを使用するように作成されたすべてのソフトウェアが変更なしで動作し続けることを許可しながら（後方互換性と呼ばれる概念）、「UTF-8」と呼ばれる別のデータ形式が導入されました。

ASCIIは、依然として最も一般的なソースコードの形式です。このアーカイブのすべてのリールには、ASCII文字のガイドが含まれています。ASCIIはUTF-8のサブセットです。つまり、すべてのASCIIエンコーディングもUTF-8エンコーディングです。ガイドリールには、すべてのUTF-8文字の仕様がさらに含まれています。このアーカイブ内のほとんどすべてのテキストファイルは、UTF-8としてエンコードする必要があります。

非テキストファイルには、画像やフォーマットされたドキュメントを表すためのファイルが含まれます。広く使用されている規則は、ファイル名が「。」で終わることです。文字の後にファイルの種類を示す接尾辞が続きます。たとえば、.jpgで終わるファイル名は、JPEG画像ファイルである可能性があります。.PNGで終わるファイルは、おそらくポータブルネットワークグラフィックイメージファイルです。.pdfで終わるファイルはPortable Document Formatファイルです。

テキストファイルを示す単一のサフィックスはありません。むしろ、ソースコードの場合、サフィックスは、コードが記述されているプログラミング言語またはマークアップ言語を示す可能性が高くなります。プログラミング言語およびマークアップ言語については、以下で詳しく説明します。

アーカイブの内容を抽出する方法
ここでは、特定のアーカイブされたリポジトリをさまざまな構成ファイルに解凍する方法の概要を説明します。繰り返しますが、このプロセスは以下で構成されます。

リポジトリーのデータがアーカイブされる特定のリールとフレームを識別する。

QRコード、それらのフレームの黒、白、灰色のピクセルのフィールドを、1と0のシーケンス（少なくとも数千、多くの場合数百万）のバイナリファイルにデコードします。

バイナリファイルをより長い非圧縮アーカイブファイルに解凍します。

アーカイブファイルを、含まれる個別のサブファイルに解凍します。ただし、このステップを省略しても、アーカイブデータは一般的にわかりやすいものですが、煩雑です。

最後に、それらの各サブファイル（それ自体が非常に短いものから非常に長いものまで1と0のシーケンス）を、テキストファイルの場合、書き込まれた文字に変換します。

リポジトリのデータがアーカイブされる特定のリールとフレームを特定する
フィルムの各リールは、空のフィルムのリーダーから始まり、ゼロ参照フレームは、空のフレームの1つのコーナーにある黒い実線の長方形で構成されています。人間が読み取れる次のフレームは、リールに関する情報を含むコントロールフレームです。それに続いて目次があり、次にユーザーデータファイルのリストが含まれます。

このリールの各リポジトリは、それらのユーザーデータファイルの1つです。リストには、一意のID、ファイルID、およびそれらの各ファイルの名前が含まれています。たとえば、PythonアカウントのCPythonリポジトリのファイルIDは12345、名前はpython_cpython.tarです。

ユーザーデータファイルのリストの後に、デジタルデータの場所のリストが続きます。このリストには、ファイルID、開始フレーム、開始バイト、終了フレーム、および終了バイトが含まれます。したがって、架空のCPythonの例を使用すると、このリストのIDが12345のアイテムは、開始フレームが054321、開始バイトが03210321、終了フレームが054545、終了バイトが12321232になります。

つまり、CPythonデータを取得するには、このフィルムリールのフレーム54321に移動します。以下に説明する方法で、開始フレーム54321から終了フレーム54545までのすべてのフレームをバイナリ値にデコードします。これにより、54321から54545までの番号が付けられた225個のデータが得られます。これは、データのない一連の空白の部分から始まります。最初の空白以外のデータの最初の3210320バイトを破棄します。すべての「中間」データを順番に追加します。最後に、最後のデータ54545の最初の12321232バイトを追加します。これで、完全なCPythonリポジトリが単一の圧縮アーカイブファイルとしてアセンブルされました。

QRコードからバイナリファイルへのデコード
フィルムフレームをバイナリデータにデコードする方法の詳細は、人間が読める形式の表現情報に記載されています。これは、アーカイブのすべてのフィルムリールの先頭にある目次の後にあります。この情報はすべてのリールにあるため、個々のリールがアーカイブから分離されていても、その内容を解読することができます。その表現情報には、次のものが含まれます。

1. GitHubアーカイブプログラムのガイド（このドキュメント）

1. GitHub記述インデックス、このリールのすべてのリポジトリのリストと簡単な説明

1. 表現情報の説明

1. デジタル保存とデータの取得方法、データ取得の詳細の概要

1. ストレージメディアの説明

1. データ検索テクノロジー

1. 一般保存リール構造（リール形式）

1. 一般的な4Kフレーム形式の説明

1. 開梱ライブラリーの説明（QRコード用）

1. ライブラリのソースコードの開梱

1. ASCIIデータ形式の仕様

1. Cプログラミング言語の仕様

1. TARアーカイブファイルのソースコード

1. PDFソースコード

1. XZファイル形式の仕様（圧縮/解凍用、以下で説明）

これらの項目の6番目のデータ検索テクノロジドキュメントでは、スキャナーを使用してデジタルでエンコードされた単一のフィルムフレームのデータをキャプチャし、コンピューター分析に適した形式に変換するための要件とプロセスについて説明しています。8番目のGeneric 4K Frame形式の記述は、コンピューターがこのようなスキャンした画像を取得してバイナリデータに変換するために必要なソースコードを含む技術情報を提供します。

原理的には、コンピューターを使用せずにリポジトリをQRエンコードデータからバイナリデータに変換することが理論的に可能です。しかし、それは非常に困難であり、おそらく数か月または数年ではないにせよ、何週間にもわたって十分に組織化されたコミュニティからの相当な努力を必要とするでしょう。リポジトリの内容はコンピュータ上で実行することを目的としたソフトウェアであるため、コンピュータが存在しない場合の使用は最小限でも最小限です。

このアーカイブの継承者がコンピュータを持っていない場合は、所有するまでアーカイブ全体を安全に保管する必要があります。人が読める技術ツリーの目的の1つは、このような事態が発生した場合に、テクノロジーとコンピューターの開発を加速することです。（それの他の目的は、将来の歴史家のために私たちの技術とその開発を成文化することです。）

アーカイブファイルを、含まれる個別のサブファイルに解凍する
各リポジトリのバイナリファイルは、Tape ArchiveのTARと呼ばれる形式です。TARファイルは基本的に、複数のファイルを1つの終わりを次の始まりに接続することによってグループ化することによって構成されます。TARファイルには、任意の数のディレクトリとサブディレクトリに分割された、任意の数の任意のサイズのファイルを含めることができます。

TARファイル内の各サブファイルの前には512バイトのヘッダーレコードがあり、スクロールメタファーのテープのように機能します。このヘッダーレコードには、名前やサイズなど、ファイルに関する情報が含まれています。アーカイブの終わりは、少なくとも2つの連続する512バイトブロックで示されます。

TARファイルは基本的に、それらの間にテキストレコードを持つファイルの単なるコレクションであるため、TARファイルにすべてのテキストファイルが含まれている場合、それ自体をテキストファイルとして扱うことができます。混在している場合は、構造化された意味のあるテキスト（構成テキストファイル）と理解できない意味不明なもの（構成テキスト以外のファイル）が混在するテキストファイルとして扱うことができます。

TARファイル内にTARファイルをネストし、コンテナを別のコンテナにネストすることができます。これが、アーカイブされたデータのほとんどが格納される方法です。特定のリポジトリについて、外部TARファイルには少なくとも次のものが含まれます。

METAと呼ばれる単一の非圧縮メタデータファイル。これには、リポジトリ名、アカウント名、説明、言語、スター数、フォーク数が含まれます
COMMITSという名前の圧縮された（以下を参照）ファイル。これには、リポジトリに対して行われた変更のログが含まれます。
実際のリポジトリーの内容を含む圧縮TARファイルであるrepo.tar.xzという名前のファイル
wiki、ghページ、問題、プルリクエストなどの他のメタデータも、個別の圧縮ファイルとして含まれる場合があります。

TARファイルの特定の詳細、およびそれらをエンコードおよびデコードするためのソフトウェアは、アーカイブのすべてのリールの表現情報にあります。

圧縮ファイルを読み取り可能な非圧縮ファイルに解凍する
できるだけ多くのリポジトリとできるだけ多くのデータを含めるために、ほとんどのデータは圧縮されています。圧縮とは、少量のデータを使用してより多くの量を表現することを意味します。そのためには、パターンとそのより多くの量の繰り返しを使用します。たとえば、9回続けて文字を書く代わりに、9aが非圧縮テキストaaaaaaaaaであることを読者が理解していると確信している場合、圧縮テキスト9aを書くだけで済みます。

効果的な圧縮アルゴリズムはそれよりはるかに複雑ですが、同じ原理が適用されます。このアーカイブは「XZ」と呼ばれる圧縮プログラムを使用し、「LZMA」と呼ばれるアルゴリズムを使用します。各リールの2番目のデータファイルには、以下で説明する1つの非圧縮TARアーカイブファイル内のXZのソースコードとドキュメントが含まれています。 （最初のデータファイルには、利用可能なすべての人間の書き言葉による世界人権宣言が含まれています。）

LZMAは、「LZ77」アルゴリズムと呼ばれるものと「範囲エンコーディング」を組み合わせたものです。LZ77は、繰り返しデータを、そのデータの以前の出現への参照で置き換えます。たとえば、大幅に単純化すると、80バイトのフレーズが2回、400バイト離れて2回出現する場合、アルゴリズムは基本的に「400バイト前から80バイトを繰り返す」と言ってデータを圧縮します。範囲エンコーディングは、本質的にメッセージ全体を単一の非常に長い数値に変換し、それを順にエンコードできます。

データの解凍に使用されるアルゴリズムの特定のステップは、すべてのリールの2番目のデータファイルに含まれているXZソースコードによって記述されます。手動で解凍することは理論的に可能ですが、これもまた、非常に時間と労力を要するプロセスになります。実際には、動作するコンピュータが必要になります。

## 個々のファイルを文字に変換する

人類は数千年にわたって多くの文字を使用してきました。このアーカイブ内でこれらの文字を1および0として表すために使用されるエンコーディングは、「UTF-8」として知られています。単一のUTF-8文字、つまり単一の書き込まれたシンボルは、1〜4バイトのバイナリデータをどこでも占有できます。

歴史的な理由により、ソフトウェア開発が始まった時間と地域で最も広く使用されていたため、「ASCII」と呼ばれる文字（および概念）のグループは、文字ごとに1バイトで最も効率的にエンコードされます。ASCII以外のものは、1文字あたり2バイト以上としてエンコードされます。このアーカイブ内のテキストファイルのほとんどはASCIIですが、かなりの数はそうではありません。さらに多くの場合、ほとんどがASCIIであり、ASCII以外の文字が時々含まれます。

ASCIIの詳細な仕様は、アーカイブのすべてのリールの表現情報に記載されています。UTF-8の詳細な仕様は、ガイドリールにあります。アーカイブのすべてのリールにある最初のデータファイルには、世界人権宣言のテキストがすべての利用可能な人間の書き言葉で含まれています。これは、変換ツールとしても、ASCIIおよびUTF-8の例としても機能します。

## ファイルの種類

さまざまな理由で作成されたさまざまな種類のテキストファイルがあります。ここでの主な種類、このアーカイブが存在する理由は、ソースコードです。ソースコードは非常に高密度で非常に構造化されたテキストで、「{」や「;」などの記号が含まれています 非常に重要です。

ソースコードの重要な点は、コンパイラによって読み取られるように記述されていることです。コンパイラーはソフトウェアであるため、別の言い方をすれば、ソースコードはコンピューターで読み取れるように作成されます。優れたコードは、ソフトウェアの分野で熟練し、教育を受けている他の人間が理解できるように書かれています。しかし、それはコンパイラがそれを理解できる場合にのみ正しいです。

そのコンパイラーは、テックツリーに記述された複雑なシーケンスを介して、ソースコードを1と0のシーケンスに変換し、コンピューターがコードによって記述された機能とアクティビティを実行するようにします。非常に単純な例をとると、コードの行

```
for（int i = 0; i <5; i ++）{}
```

コンパイラーによってコンピューターに送られる一連のバイナリー命令に変換されます。これにより、レジスターと呼ばれるコンピューターのごく一部がその値を0に設定し、その後その値を1、2、3にインクリメントします。 （これは有用なコードの例として意図されたものではありません。これは、ソースコードを実行中のソフトウェアに変換するための多層プロセスの単なる例示です。）

JSON、XML、HTMLなどの他の種類のテキストファイルは、コンピューターのデータを（コマンドではなく）保存するために使用されます。構造化された形式のため、このファイルのように構造化されていないストーリーテリングテキストよりも読みにくくなっていますが、一般的には人間も読むことができます。

他のほとんどの種類のテキストファイルは、最終的に人間が読み取ることを目的としています。あなたが現在読んでいるこのファイルのように、いくつかは単純な、ほとんど構造化されていないテキストです。アーカイブで広く遭遇するのはMarkdownです。これは、ファイルの.md拡張子によって示されます。これは、生の形式で人間が読み取れるように意図されていると同時に、次のように構造化されている中間形式の一種です。コンピュータは、それらをより視覚的に魅力的で有用なレイアウトにフォーマットできます。このアーカイブ内のほとんどのリポジトリにはREADME.mdマークダウンファイルがあり、これは通常、リポジトリの最初の紹介として意図され、それが何であるか、存在する理由、およびその使用方法を説明します。

非テキストファイルの最も一般的な形式の概要も役立つ場合があります。コンパイルされたコードは非テキストです。JPGおよびPNGファイルはデジタル形式で画像をエンコードし、MP3およびWAVはオーディオをエンコードします。PDFファイルは、正確で完璧なフォーマットでドキュメントをエンコードします。前述のように、ZIPおよびTARファイルはコンテナファイルであり、さらに他の多くのファイルを含めることができます。

## 人間の言語とプログラミング言語

### 人間の言語

今日、人類が使用している何千もの書き言葉があり、さらに多くの話し言葉があります。それらのほとんどは比較的少数の人口によってのみ使用されますが、少なくとも6千万人が第一または第二の言語として使用する少なくとも20の言語があります。

世界で最も広く使用されている言語は英語と中国語です。歴史的な理由により、長年にわたってほとんどのソフトウェア開発は英語圏の国で行われていたため、一時期は英語がソフトウェアのデフォルト言語になりました。ほとんどのプログラミング言語では、構文に英語の単語を使用しています。このアーカイブへのガイドが最初に書かれた言語です。

このアーカイブの継承者が英語を知っていることは保証されていませんが、無期限に続く可能性が特に高い言語のようです。他の言語へのガイダンスが役立つ場合は、世界人権宣言の利用可能な500以上の翻訳を非圧縮UTF-8ファイルとしてすべてのリールの最初に、また技術ツリー内に含めています。この宣言は、私たちの時代のすべての人間の権利と自由のリストであり、決して持ち去られてはなりません。

### プログラミング言語

プログラミング言語は、人間がコンピュータに指示を伝えるために使用する言語です。それらはソフトウェアが表現される言語です。他の（訓練された）人間もプログラミング言語で書かれたソフトウェアを読むことができるはずですが、それは二次的な目標です。

プログラミング言語は一連の事前定義された要素であり、そのほとんどは単語であり、指定された方法で指定されたアクションを実行するようにコンピューターに指示するために構造化された方法で配置できます。このような命令の集まりは、プログラムまたはソースコードとして知られています。ソースコードは本質的には、フリーズされた、書かれた形式のソフトウェアです。

プログラムは通常、ステートメントと呼ばれる個別のステップに分割され、関数と呼ばれるコレクションにグループ化されます。プログラム全体が単一のファイルに含まれている場合もあれば、数千に分散している場合もあります。

何百もの異なるプログラミング言語があり、多くの異なる形式、アプローチ、および哲学に広がっています。一部は個別のバイナリファイルにコンパイルされてから実行されます。「解釈された」言語として知られているいくつかは、中間段階なしで効率的にコンパイルされ、一度に実行されます。最近のほとんどのプログラミング言語には、事前に記述された関数のライブラリーが含まれており、そのようなライブラリーは非常に膨大で複雑な場合があります。今日最も人気のあるプログラミング言語には次のものがあります。

1. C は、最も古く、最も速く、最も普遍的で、最も強力な言語の1つであり、いくつかの点で単純ですが、他の方法では非常に制限されており、常に直感的で、読みやすく、学習しやすいとは限りません。

1. C ++、Cのより複雑で抽象的な強力な進化。

1. C＃、バイナリマシンコードにコンパイルされたのではなく、解釈された「ランタイム」にコンパイルされたさらなる進化。

1. Javaは、C＃に似ていますが（以前のものですが）、おそらく今日最も広く使用されている言語です。

1. JavaScriptは、名前が類似しているにもかかわらずJavaとは異なり、「ECMAScript」とも呼ばれ、最初はWebブラウザ内で完全に使用される言語です。つまり、インターネットサーバーと呼ばれるリモートコンピュータからデータをフェッチ、解釈、および表示するプログラムです。 ; しかし今日では、これらのサーバーでも広く使用されています。

1. TypeScript。より厳密なルールを備えたJavaScriptの形式であり、バグとも呼ばれるエラーがプログラムに侵入する可能性が低くなります。

1. Pythonは科学者の間で人気のあるエレガントな言語で、強力で優れた第一言語です。

1. Rubyは直感的な言語で、ほとんどの場合、その記述はほとんど英語で書かれたように読みます。

1. Go、特に並列化されたプログラム（複数の関数が同時に独立して実行されるように記述されたプログラム）に優れたシンプルで強力な言語。

1. Swiftは、10億人が使用する電話やその他のデバイス用に作成するために使用される新しい言語です。

1. Rustは、Cの代替として意図されており、危険なバグの可能性がはるかに低くなります。

1. PHP、インターネットサーバーで使用される単純な言語。

1. Lispは、プログラミングに対して根本的に異なる、関数優先のアプローチを持つ非常に古い言語です。

1. SQL、データベースと呼ばれるデータの構造化された非常に効率的なストアからデータをフェッチするために使用される非常に異なる種類の言語。

1. アセンブラー（またはアセンブリー）。非常に不可解で、制限されていますが、高速で強力な言語のファミリーであり、言語構造と問題のコンピューターのマシンコードの間に直接的な関係があります。ハーフコンパイルされたコードと見なされる場合があります。

## 開発、依存関係、オープンソース

開発
単一の単純なソースコードファイルを取得し、それをコンピューター内で電気インパルスに変換するプロセスは非常に複雑です。この複雑さに対処するには、抽象化のレイヤーを使用します。命令セットと呼ばれる抽象化により、単一のコンパイラーからのマシンコード出力をさまざまな種類のコンピューターで使用できます。ソースコードの作成者は、通常、そのコードを実行するために使用されるコンピューターの種類、さらにはどの命令セットが使用されるかを知る必要もありません。これはコンパイラによって抽象化されます。

現代のソフトウェアは、1人の作者が1台のコンピュータの1つのプログラムで作業するよりもはるかに複雑です。これは、多くの作成者が1つのプロジェクト内の多くのファイルで同時に作業し、多くの場合、複数のプログラミング言語を使用しています。さらに、すべてのプロジェクトは、ツールやコンポーネントとして他の独立した自己完結型プロジェクトに依存していますが、これらのプロジェクト自体も積極的に取り組んでおり、さらに他のプロジェクトに依存しています。これらすべての可動部分をエレガントかつ効率的に連携させることは、最新のソフトウェア開発の課題です。

ソフトウェア開発者としても知られる複数のソースコード作成者が1つのプロジェクトで作業する場合、それぞれが独自のコンピューターを持ち、プロジェクト全体のコピーをコンピューター上に持っています。それぞれが変更を加える場合、それぞれが同じプロジェクトの異なるバージョンを持っています。プロジェクトの複数のバージョンを調整するプロセスは、バージョン管理と呼ばれます。バージョン管理ソフトウェアによって管理されます。このアーカイブでは、Gitと呼ばれるソフトウェアにより、GitHub自体に名前が付けられています。このアーカイブのすべてのリポジトリはGitリポジトリです。

Gitは、ソフトウェアの異なるバージョンを自動的に1つのまとまった形式にマージし、最小限の人間の介入を必要としません。また、Gitは完全な履歴を保持しているため、必要に応じて以前のバージョンにロールバックできます。ただし、スペースを節約するために、このアーカイブのリポジトリには通常、Git履歴が含まれていません。

複数の開発者が同時に複数の異なるパスでプロジェクトを実行する場合、これはプロジェクトの分岐と呼ばれ、それらのパスは分岐と呼ばれます。合意されたプロジェクトのメインブランチは、トランクまたはマスターブランチと呼ばれます。Gitは、開発者が2つのブランチ間の違いを要約し、それらを他のブランチに結合することを提案するために使用できる機能を提供します。これはプルリクエストと呼ばれます。最新のソフトウェア開発は、主にプロジェクトの分岐、分岐でのソフトウェアの書き込みまたは編集、および完了時に作業をマスターブランチに組み込むためのプルリクエストの送信で構成されます。

## 依存関係

本質的にすべてのプログラミング言語は、他の人の作業に基づいて構築することをサポートしています。他の人の作業を再利用しないと、すべてのプロジェクトは非常に困難になり、非常に遅くなり、実世界で実際に使用されるプロジェクトはほとんどありません。

Aが作業を行うためにプロジェクトAにプロジェクトBを含める必要がある場合、AはプロジェクトBに依存していると呼ばれ、BはプロジェクトAの依存関係と呼ばれます。Aには多くの依存関係があり、それぞれに多くの依存関係があります。独自の依存関係など。さらに、各依存関係は、特定のプロジェクトの特定のバージョンまたはバージョンの範囲に対するものです。プロジェクトの複数の依存関係のすべてのレイヤーの完全な項目化は、依存関係ツリーと呼ばれます。

Generally, dependencies are itemized inside source code files, usually at the very top, and each time the compiler or interpreter finds a dependency, it looks for it in a set of predefined directories. Because the dependency tree for a project can be very complex, it is sometimes itemized in its entirety in a single file within a project known as a package list. For instance, Ruby projects may have a Gemfile for this purpose, and JavaScript projects may have a package.json file. This allows a kind of tool known as package management software to fetch all the dependencies for a project at once, from one or more Internet servers.

このアーカイブの場合、特定のプロジェクトの依存関係がアーカイブの別の場所に存在する可能性があります。アーカイブで依存関係を見つけるには、最初にソースコードまたはパッケージリストで依存関係の名前を見つけます。その詳細は言語やフレームワークによって異なり、次にガイドリールのマスターインデックスを使用します。または、存在しない場合は、各リールの前にあるインデックスを使用して、問題のリポジトリが見つかるリールとフレームを特定します。

## オープンソース

コンピュータ上でプログラムを実行するには、コンパイルされたマシンコードのみが必要なので、ソースコードを秘密に保ちながら配布することが可能です。これはクローズドソースモデルと呼ばれます。コンピューティングのごく初期には、ソースコードは通常、そのマシンコードと共に配布されていましたが、その後、ソフトウェアが収益性の高い業界になるにつれて、クローズドソースモデルがより一般的になりました。

それ以来、誰もがコピー、分岐、改善できるようにソースコードを公開することは、ソフトウェア開発へのはるかに効果的なアプローチであることがわかりました。プロジェクトのソースコードを読むことができる人が増えるほど、考えられるニーズと有用な新機能を特定する人が増える、プロジェクトに貢献するのに十分なほどプロジェクトを理解する人が増える、バグを見つけて修正を送信する人が増える、テストして検証する人が増えるその新しいコードは機能します。

一般に、クローズドソースは、新しいより良いアイデアを見つけて採用するのに苦労する、小さくて島の断片化されたコミュニティにつながります。オープンソースは相互に関連する大きなコミュニティにつながり、それぞれが互いのプロジェクトの成長と繁栄、成功を助け、互いの作業を依存関係として使用したり、コードを再利用したり、互いに学び合ったりします。オープンソースソフトウェアは、すべての人類を集合的に使用するためのツールキットであり、私たちが持っているツールが多ければ多いほど、種としての進歩をより速く、より良くすることができます。
